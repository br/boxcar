#!/bin/bash

#/ NAME
#/     build-all - builds vagrant boxes from scratch
#/
#/ SYNOPSIS
#/     bin/build all virtualbox precise
#/     bin/build all virtualbox precise precise clean ...
#/     bin/build all aws raring
#/     bin/build all aws raring raring clean ...

# figure out the project root under which bin, lib live
shome="$(unset CDPATH; cd -P -- "$(dirname -- "$BASH_SOURCE")/.." && pwd -P)"

# load a jason bourne library
source "$shome/libexec/_jason"
require boxcar

DEFINE_boolean build "$FLAGS_FALSE" "Also run the :build hooks"
DEFINE_boolean clean "$FLAGS_FALSE" "Build the basic clean boxcar"
DEFINE_string final "" "Box name for the end train"

function run {
  logger_info "running $*"
  "$@"
}

function refresh {
  local nm_input="$1"; shift
  local nm_output="$1"; shift

  local ssh_username="ubuntu"
  if [[ "$FLAGS_provider" = "virtualbox" && "${1%%:*}" = "clean" ]]; then
    ssh_username="vagrant" # TODO this hack goes away if we make our own veewee builds
  fi

  if vagrant box list | awk -v box="$nm_output" -v virt="$FLAGS_provider" '$1 == box && $2 == "(" virt ")" { counter += 1 } END { exit !counter }'; then
    vagrant box remove $nm_output $FLAGS_provider
  fi

  (cd $FLAGS_builddir/${nm_output}.vagrant 2>&- && vagrant destroy -f > /dev/null 2>&-) || true

  run $shome/bin/train start \
    --boxname $nm_input \
    --release_dir $FLAGS_builddir/${nm_output}.vagrant \
    --output $FLAGS_builddir/$nm_output.box \
    --ssh_username "$ssh_username" \
    "$@" 2>&1 | tee $FLAGS_builddir/$nm_output.log
  if [[ "$PIPESTATUS" != 0 && "$PIPESTATUS" != "0" ]]; then
    logger_fatal "train start failed with pipe status /$PIPESTATUS/"
    return "$PIPESTATUS"
  fi
  vagrant box add $nm_output $FLAGS_builddir/$nm_output.box

  rm -rf $FLAGS_builddir/${nm_output}.vagrant
}

function build_boxcars {
  # setup the initial box import
  output="$1"; shift

  # build each boxcar
  while [[ "$#" > 0 ]]; do
    local raw_hook="$1"; shift

    adjust_build_phase "$raw_hook"
    nm_hook="${raw_hook%%:*}"
    logger_info "hook: $nm_hook, phase: $BUILD_IMAGE_PHASE"
    input="$output"

    if [[ "$#" = 0 && -n "$FLAGS_final" ]]; then
      output="$FLAGS_final"
    else
      if [[ "$nm_hook" = "clean" ]]; then
        output="$output-${nm_hook}(pre)"
      elif [[ "$nm_hook" = "$FLAGS_provider" ]]; then
        output="${output%-clean*}-clean"
      else
        output="$output-$(echo $raw_hook | perl -pe 's{:(\w+)}{($1)}g')"
      fi
    fi

    refresh $input $output $raw_hook
    if [[ "$PIPESTATUS" != 0 ]]; then
      logger_fatal "refresh failed with pipe status $PIPESTATUS"
      return "$PIPESTATUS"
    fi
  done
}

function build_train {
  mark_output
  mark_log "${FLAGS_release}-${FLAGS_provider}"

  FLAGS_builddir="$BOXCAR/build/${FLAGS_release}-${FLAGS_provider}"
  export OVERRIDE_builddir="$FLAGS_builddir"

  FLAGS_cachedir="$BOXCAR/build/${FLAGS_release}"
  export OVERRIDE_cachedir="$FLAGS_cachedir"

  # boxcar raring
  local train="${FLAGS_release}"

  if [[ "$FLAGS_clean" = "$FLAGS_TRUE" ]]; then
    # boxcar raring -> raring-clean(pre)
    build_boxcars $train clean

    # boxcar raring-clean(pre) -> raring-clean
    build_boxcars "$train-clean(pre)" ${FLAGS_provider}
    train="$train-clean"
  else
    # boxcar $1
    train="${FLAGS_release}-$1"; shift
  fi
  
  if [[ "$#" > 0 ]]; then
    build_boxcars "$train" "$@"
  fi
}

# entry point
function main {
  export OVERRIDE_provider="${FLAGS_provider}"
  export OVERRIDE_release="${FLAGS_release}"
  build_train "$@"
}

require sub "$BASH_SOURCE" "$@"



