#!/bin/bash

#/ NAME
#/     build docker - builds train with docker (shell provider)
#/
#/ SYNOPSIS
#/   bin/build docker
#/
#/ EXAMPLES
#/     $ bin/build docker

# figure out the project root under which bin, lib live
shome="$(cd -P -- "$(dirname -- "$BASH_SOURCE")/.." && pwd -P)"

# load a jason bourne library
source "$shome/libexec/_jason"
require boxcar

DEFINE_string "image" "ubuntu" "Image to use for bootstrap, defaults to public ubuntu image"

function until_vagrant {
  logger_info "waiting for $@"

  while true; do
    local status="$(instance_status)"

    local wanted
    for wanted in "$@"; do
      if [[ "$status" = "$wanted" ]]; then
        break 2
      fi
    done
    echo -n "."
    sleep 5
  done

  echo
}

function instance_status {
  if [[ ! -f "$FLAGS_release_dir/.vagrant/machines/default/docker/id" ]]; then
    echo "null"
  fi

  id_instance="$(cat $FLAGS_release_dir/.vagrant/machines/default/docker/id)"
  docker inspect "$id_instance" | grep "Running" | awk '{print $2}' | cut -d, -f1
}

function conf_vagrant {
  local nm_box="$1"; shift

  local tmp_dna="$(mktemp -t XXXXXXXXX)"
  cat > "$tmp_dna" <<EOF
  { 
    "run_list": ["vagrant::docker"], 
    "vagrant": { 
      "box": "${nm_box}",
      "release_dir": "$FLAGS_release_dir",
      "ssh_username": "$FLAGS_ssh_username",
      "shell_args": "bash -c '$(cat $shome/libexec/init-docker | perl -pe 's{\s*$}{\\n}g')'"
    }
  }
EOF
  cat $tmp_dna
  $shome/bin/cook -j "$tmp_dna"
  rm -f "$tmp_dna"
}

function build_keypair {
  true
}

function delete_keypair {
  true
}

function early_termination {
  true
} 

function bundle_vagrant {
  if [[ -z "$FLAGS_output" ]]; then
    return 0
  fi

  local base_image="$(basename $FLAGS_output .box | perl -pe 's{:(\w+)}{\($1\)}g')"
  local tag_image="$(TZ=UTC date "+%Y-%m-%d-%H-%M")"
  local nm_image="${base_image}_${tag_image}"
  local id_instance="$(cat $FLAGS_release_dir/.vagrant/machines/default/docker/id)"

  logger_info "creating image $nm_image from instance $id_instance"

  local id_image="$(docker commit $id_instance $base_image $tag_image)"
  if [[ -z "$id_image" ]]; then
    logger_fatal "could not retrieve image id"
    return 1
  fi
  (cd $FLAGS_release_dir && BUNDLE_GEMFILE="$shome/Gemfile" bundle exec vagrant destroy -f)

  local tmp_metadata="$(mktemp -d -t XXXXXXXXX)"
  cat > "$tmp_metadata/metadata.json" << __EOF
  {
        "provider": "docker"
  }
__EOF
  cat > "$tmp_metadata/Vagrantfile" << __EOF
  Vagrant.configure("2") do |config|
    config.vm.provider :docker do |docker, override|
      docker= "$id_image"
      override.vm.synced_folder ".", "/vagrant", :id => "vagrant-root", :disabled => true
    end
  end
__EOF
  rm -f "$FLAGS_output"
  tar cvfz "$FLAGS_output" -C "$tmp_metadata" metadata.json Vagrantfile
  rm -rf "$tmp_metadata"
} 

function demo_vagrant {
  local nm_keypair="$1"; shift
  local nm_box="$1"; shift

  conf_vagrant "$nm_box"
  (cd $FLAGS_release_dir && BUNDLE_GEMFILE="$shome/Gemfile" bundle exec vagrant up --provider docker)
  until_vagrant "true"
  local id_instance="$(cat $FLAGS_release_dir/.vagrant/machines/default/docker/id)"
  until_port_open "$(docker inspect $id_instance | awk '$1 ~ /IPAddress/ { split($2,ip,"\""); print ip[2] }')" 22
  demo_in_vagrant "$@"
}

function forwarded_ssh_port {
  echo "22"
}

# entry point
function main {
  cd $shome
  time build_vagrant "$@"
}

require sub "$BASH_SOURCE" "$@"
